# 1st Trimester Evaluation

## What did I achieve to manage?

### Set-up Projects and IDEs  

One of the first steps in this course was working with IDEs—the workspace where I develop code—and setting up new projects from scratch. Getting familiar with different development environments was essential for streamlining my workflow and improving efficiency.  

I successfully set up React+Vite projects, ensuring a fast and optimized development environment for front-end work. On the back end, I managed Java projects built with Spring Boot, configuring dependencies, application properties, and build tools like Maven or Gradle. Understanding these setups allowed me to focus on development rather than getting stuck in configuration issues.  

Working with IDEs like **Visual Studio Code** for front-end development and **IntelliJ IDEA** for Java projects, I learned how to optimize my workspace. This included setting up extensions, using integrated terminals, debugging tools, and leveraging shortcuts to improve productivity. For Java projects, IntelliJ’s built-in Spring Boot support made it easier to manage beans, controllers, and services while providing insightful code suggestions.  

Additionally, I became comfortable navigating project structures, understanding file hierarchies, and utilizing features like version control integration (Git), automatic code formatting, and live server previews. These tools helped streamline development and made it easier to troubleshoot issues efficiently.  

Now, I know how to set up these projects from scratch and, more importantly, where to find the documentation when I need to refine configurations or troubleshoot challenges. This has strengthened my ability to work independently while ensuring I can adapt to new tools and frameworks as needed.  
<br>

> **Documentation:** [Vite+React](https://v3.vitejs.dev/guide/) | [Springboot](https://spring.io/projects/spring-boot#learn)

<br>

---
### Frameworks to Work Within Frontend and Backend  

As a newcomer to software development, I had to absorb a lot of knowledge quickly. Within the first days of the course, I was introduced to **React** and **Java**—both of which I had never worked with before. Learning a new programming language or framework can be overwhelming, but I focused on breaking things down step by step.  

The key was to stay focused and apply **SCRUM** (which I'll discuss later) on a daily basis. I had to timebox my days, weeks, and months to keep up with the pace of the course—and it worked. Setting clear goals, tracking progress, and iterating on what I learned helped me stay on track without feeling lost in the process.  

To build a strong foundation, I started studying **MOOC’s Java Programming** course from Helsinki University and followed the **official React documentation**. These resources provided structured learning paths that helped me understand the core principles behind both technologies. Instead of just memorizing syntax, I aimed to grasp the logic behind every line of code I wrote. This approach made it easier to tackle exercises and fully engage in the classes I attended.  

For React, I practiced concepts from **react.dev**, successfully completing the **"Describing the UI"** and **"Adding Interactivity"** sections. These helped me understand how to structure components, manage state, and handle user interactions effectively.  

On the backend side, I’ve been progressing through **MOOC’s Java Programming 1**, currently finishing **Part 4**. Working with Java has given me a deeper understanding of object-oriented programming, data structures, and backend logic, which are crucial for building scalable applications.  

By combining structured learning, hands-on exercises, and SCRUM principles, I’ve been able to build a solid foundation in both frontend and backend development. There’s still a lot to learn, but I’m confident in my ability to keep pushing forward.  


<br>

> **Documentation:** [React.dev](https://react.dev/learn) | [MOOC](https://java-programming.mooc.fi/)

<br>

---
### One Git to Rule 'Em All  

If I had to name my archenemy in this evaluation, it would undoubtedly be **Git**. With all its powerful features for managing and controlling projects, it can be a lifesaver—but also a nightmare when things go wrong. Keeping everything in order was challenging, especially when a single mistake could spiral into a tangled mess of commits, branches, and conflicts.  

More than once, I found myself deep in **Git’s documentation**, desperately searching for a way to undo the chaos I had created. Resetting commits, fixing merge conflicts, recovering lost changes—I had to go through it all. Each mistake, however frustrating, became an opportunity to learn how Git actually works under the hood.  

One of the most crucial lessons I learned was that **every developer needs full control over Git commands**, whether working through a terminal or an IDE. Understanding the right way to **clone, commit, push, pull, merge, rebase, and stash** is essential—not just for keeping projects organized but also for preventing irreversible mistakes.  

Now, I make it a habit to **double-check every command** before executing it, ensuring I’m working on the correct branch and that my commits are clean and meaningful. I’ve also learned to use **Git aliases and graphical tools** like GitKraken or the built-in Git tools in **VS Code and IntelliJ IDEA** to visualize changes more clearly.  

Managing repositories—both new and old—requires discipline, but with time, I’ve started to feel more in control. Git is no longer just an intimidating tool; it’s an essential skill that I’m continuously improving. There’s still a long way to go, but at least now, I make fewer messes—and when I do, I know how to clean them up.  


<br>

    Git is immutable.

<br>

> **Documentation:** [Git](https://git-scm.com/doc)

<br>

---
### SCRUM & Agile Methodologies  

It was love at first sight. From the moment I started learning about **SCRUM** and **Agile methodologies**, I knew I had found something that truly resonated with me.  

Every methodology comes with its own pros and cons, but these felt different. They aligned perfectly with my natural way of working. I’ve never been a conventionalist—I’ve always questioned rigid systems, from traditional education to corporate structures that prioritize outdated workflows over real efficiency. The standard ways of doing things always left me frustrated, feeling like there had to be a better approach.  

For as long as I can remember, I’ve been obsessed with **optimization**—not just in projects, but in **myself**. I constantly ask:  
- How can I fit into a team while maximizing my strengths?  
- How can I be better, faster, and more efficient?  
- How can I eliminate unnecessary work and stop producing waste?  

SCRUM gave me answers I had been searching for. It provided a **structured yet flexible approach** to productivity, allowing me to focus on tasks without getting overwhelmed. Timeboxing my work, setting clear objectives, and breaking tasks into manageable sprints **transformed** the way I approach challenges. More importantly, it gave me a way to communicate and **collaborate effectively with my colleagues**, ensuring that my work—and theirs—was always aligned with real goals.  

I’d even go as far as saying that I’ve finally found **the perfect fit**—the right methodology that complements my mindset and work style. Now, my focus is on **continuing to refine my skills**, pushing my knowledge to its limits, and diving even deeper into Agile principles. My goal? To keep improving, to master this way of working, and to eventually connect with **like-minded individuals** who share the same drive for efficiency, collaboration, and innovation.  

<br>

> **Documentation:** [SCRUM](https://albertprofe.dev/scrum/scrum-what-guide.html) | [Agile Manifesto](https://agilemanifesto.org/)

<br>

---
### Markdown and Its Capabilities  

During this course, I learned the **proper way to document** my projects, evaluations, and even the sprints I mentioned in the **SCRUM methodology**. For that, Markdown proved to be an **essential tool**.  

With Markdown, I can efficiently **write and structure** all kinds of annotations while keeping everything clean and readable. Unlike other documentation formats that rely on unnecessary styling or complex editors, Markdown focuses on **clarity and simplicity**. No distractions—just well-structured content with the **minimum add-ons needed** to get the message across. Everything else is either noise or irrelevant when it comes to writing clear instructions or documentation.  

One of the biggest advantages is its **lightweight syntax**, which allows me to format text, create lists, insert links, and structure content without depending on bulky tools. Whether I’m writing project documentation, API references, or SCRUM sprint summaries, Markdown ensures everything remains **consistent and easy to read**.  

As I continue refining my documentation skills, I rely on a **Markdown cheatsheet** to quickly reference the most useful and commonly used syntax. Having this handy guide helps me write more efficiently while maintaining a professional and structured approach to documentation.  

Mastering Markdown has made a significant impact on how I organize and present my work, and I see it as an invaluable skill for any developer or technical writer.  

<br>

> **Documentation:** [Markdown Cheatsheet](https://github.com/AlbertProfe/markdown_PRA/blob/master/Resources/Markdown_guides/markdown_cheat_sheet_opensource.com_.pdf)
<br>

---
### Roadmap

This point represents how I've learned to create **roadmaps**. So I would start saying that a roadmap is not something easy that you can master overnight. It really takes practice to focus on core objectives and a clear goal, trial and error, learn from real-world applications.
<br>

You have to understand first of all the purpose of a roadmap, but indeed it is much more to it. A roadmap provides a high-level strategic view of the project you're focusing on, align many goals, prioritize goals over other goals and timelines.
<br>

I started by looking existing roadmaps good and bad ones, comparing them. Seeing how big companies structure their project and product roadmap and give some insights to it into the best praxis.
<br>

Here are some keywords and core elements to do it:

- **Goals:** What are we trying to achieve?  
- **Milestones:** Key points that mark progress.  
- **Timelines:** Realistic estimates for when things should be completed.  
- **Dependencies:** What needs to be done before moving to the next phase?  
- **Flexibility:** Room for adjustments based on feedback and unforeseen challenges.  

Understanding these components helped me structure roadmaps more effectively.

>A good roadmap should provide enough clarity to guide you while remaining flexible and adaptive to any change in the process.

 
To bring my roadmaps to life, I tested various tools:  
- **Trello** for visual task management.
- **Notion** for flexible planning.
- **Miro** for visual, collaborative mapping.

Each tool had its strengths, and I learned to adapt based on the project's needs.
<br>

> **Documentation:** 

<br>

---
### Digging into Material UI  

When I started working with **Material UI (MUI)**, I quickly realized it was more than just a component library—it was a powerful tool for building **consistent, responsive, and modern** user interfaces with minimal effort. At first, it felt overwhelming due to the sheer number of components and customization options, but as I explored deeper, I began to appreciate its flexibility and efficiency.  

One of the biggest advantages of Material UI is its **pre-styled components**, which help speed up development without sacrificing design quality. From buttons and forms to modals and tables, everything is built with accessibility and responsiveness in mind. Learning how to effectively use these components allowed me to **focus more on functionality** rather than spending excessive time on UI styling.  

#### Key Learnings from Material UI  

- **Component-Based Design** → MUI provides a vast collection of reusable components, making UI development faster and more structured. I learned how to customize them to fit different design needs while maintaining consistency.  
- **Theming & Styling** → Understanding **MUI’s theming system** was a game-changer. I explored how to create and extend themes, adjust typography, and control global styling using the **`ThemeProvider`**. This made it easier to maintain a uniform look across applications.  
- **SX Prop & Styled API** → Instead of relying purely on CSS or inline styles, MUI offers the **`sx` prop** and the **Styled API**, which allows for dynamic styling with JavaScript. I practiced using both approaches and found them extremely useful for managing styles in a scalable way.  
- **Grid & Flexbox Layouts** → MUI’s **Grid** and **Box** components provided a structured way to handle layouts without manually writing Flexbox or CSS Grid styles. Understanding these helped me design responsive UIs more efficiently.  
- **Form Handling & Validation** → MUI’s input components work seamlessly with form libraries like **React Hook Form** and **Formik**. I learned how to integrate them properly to ensure form validation and user-friendly error handling.  
- **Performance Optimization** → Since MUI loads a lot of styles and dependencies, I explored ways to **optimize performance**, such as using tree-shaking to only import necessary components and reducing unnecessary re-renders by leveraging memoization techniques.  

Initially, it took some time to get comfortable with MUI’s structure, but now I can **build professional-looking interfaces much faster** while ensuring they are scalable and maintainable. My next goal is to dive deeper into **advanced theming and dynamic UI customizations** to make applications even more tailored and interactive.  

> **Documentation:** [Material UI Docs](https://mui.com/material-ui/getting-started/)


---
### Exploring Axios  

When I started integrating **APIs into my React projects**, I quickly found that **Axios** made handling HTTP requests much more manageable than the native Fetch API. The main advantage was its clean, straightforward syntax and automatic handling of JSON responses.  

At first, I was amazed by how easy it was to perform **GET and POST requests** with Axios. Instead of dealing with complex syntax and parsing responses manually, Axios took care of it all for me, making the entire process simpler and more intuitive.  

I also appreciated how I could set **global configurations**, such as the **base URL** and **headers**, so I didn’t have to repeat them for every request. This helped streamline my code and make it more maintainable, especially when working with APIs that required authentication tokens.  

Another aspect I found helpful was **error handling**. Axios made it easier to manage errors by providing clear responses when things went wrong, so I could handle failures more effectively without extra steps.  

Overall, Axios has made working with APIs in React more efficient. As I continue exploring its capabilities, I’m planning to look into **request optimizations** to further enhance performance in larger applications.  

> **Documentation:** [Axios Docs](https://axios-http.com/es/docs/intro)  


---
### Learning Hooks in React  

As I dove deeper into **React**, one of the biggest challenges—and most exciting aspects—was understanding **Hooks**. Hooks allow functional components to manage state and lifecycle events without relying on class components. At first, the concept felt a bit abstract, but through practice and real-world application, I started to grasp their power and flexibility.  

Here’s a breakdown of the key hooks I’ve learned so far and how I use them:  

- **`useState`** → The foundation of state management in functional components. I use it to store and update simple variables or objects that trigger re-renders when changed.  
- **`useEffect`** → Essential for handling side effects like fetching data, setting up event listeners, or updating the DOM manually. I’ve learned that understanding its dependency array is key to avoiding unnecessary re-renders and infinite loops.  
- **`useContext`** → A game-changer for state management across components without prop drilling. It allows me to share global state, such as themes or authentication data, without passing props manually.  
- **`useRef`** → A powerful hook for persisting values across renders **without causing re-renders**. I mainly use it to reference DOM elements, store previous values, or manage timers.  
- **`useReducer`** → When `useState` isn’t enough for complex state logic, `useReducer` comes to the rescue. It follows a more structured pattern, making it great for managing state transitions in large applications.  
- **`useMemo`** → Optimizes performance by **caching computed values** and preventing unnecessary recalculations. I use it when dealing with expensive computations that shouldn’t re-run on every render.  

At first, it was hard to use hooks everywhere without truly understanding when and why to apply them. But as I kept building projects and experimenting, I learned that **the key is knowing which hook to use for each scenario**. Now, I feel much more comfortable leveraging hooks to write cleaner, more efficient React applications.  

> **Documentation:** 
<br>

---
### Exploring REST APIs, JPA & Postman  

As I dove into backend development, I began working with **REST APIs** and **JPA (Java Persistence API)**—two critical components for creating and interacting with databases and external services. These technologies work together to build scalable, robust applications.  

First, I learned that **REST APIs** allow different systems to communicate with each other over HTTP. With REST, the client sends HTTP requests to the server, and the server responds with data, typically in **JSON format**. The key **HTTP methods** used are:  
- **GET**: Retrieve data  
- **POST**: Create new data  
- **PUT**: Update existing data  
- **DELETE**: Remove data  

I quickly grasped how each method has a specific role in manipulating resources, and understanding this was essential for structuring clean and effective APIs.  

Then, I explored **JPA**, which simplifies database interactions. With JPA, I learned how to use **Entities** to map Java objects to database tables and perform **CRUD (Create, Read, Update, Delete) operations** without writing complex SQL. This abstraction allowed me to focus more on business logic rather than managing raw SQL queries.  

JPA also made it easy to handle **Entity Relationships** like **one-to-many** and **many-to-many**. By mapping these relationships between tables, I could build more complex data models while keeping the code clean and maintainable. The **repository pattern** in Spring Boot automatically generates queries based on the method names, which helped me write less boilerplate code.  

### How Postman Helps with REST APIs & JPA  

One of the tools I found indispensable in this process is **Postman**. It's an API client that simplifies the process of testing, developing, and debugging APIs. With Postman, I could:  
- **Send HTTP requests** to my REST endpoints (GET, POST, PUT, DELETE) and examine the responses in detail.  
- **Test API functionality** without having to integrate it with the frontend, making development faster.  
- **Simulate different API scenarios**, like sending data with various HTTP status codes, headers, and body content, which helped me verify that both my API and the database were working correctly.  
- **Automate tests** with Postman’s built-in tools, which allowed me to confirm that everything from data retrieval to updates was functioning as expected.  

Postman became my go-to tool for **API testing and validation**, especially when working with complex REST APIs connected to a backend powered by JPA.  

#### Key Points from REST APIs & JPA  
- **REST APIs** are essential for enabling communication between systems over HTTP, and understanding how to handle HTTP methods is crucial for building efficient services.  
- **JPA** allows for object-relational mapping, letting you interact with the database through Java objects rather than raw SQL, simplifying CRUD operations.  
- **Entity Relationships** in JPA enable you to model complex data structures and efficiently map them to the database.  
- **Postman** is an essential tool for testing, debugging, and validating REST APIs, allowing you to simulate API calls and verify their functionality before integrating them into the frontend.  

These technologies, combined with Postman, provided the foundation I needed to build reliable backend systems. As I continue learning, I plan to explore **advanced querying techniques** in JPA and further optimize my APIs for performance.  

> **Documentation:** [Spring Boot REST API Docs](https://docs.spring.io/spring-boot/index.html) | [Spring Boot JPA Docs](https://docs.spring.io/spring-data/jpa/docs/current-SNAPSHOT/reference/html/#reference) |  [Postman Docs](https://learning.postman.com/docs/introduction/overview/)  


---
### Understanding CRUD Operations  

In backend development, **CRUD** represents the four basic operations for managing data:  

- **Create**: Add new data to the system.  
- **Read**: Retrieve data from the system.  
- **Update**: Modify existing data.  
- **Delete**: Remove data from the system.  

These operations are essential for interacting with a database and are the foundation of most web applications. In the context of **REST APIs** and **JPA**:  

- **Create** is typically done with a **POST** request in REST APIs. In JPA, it's done by saving a new entity to the database.  
- **Read** is handled with a **GET** request in REST APIs, allowing data retrieval. In JPA, it's done by querying the database for the desired data.  
- **Update** is achieved with **PUT** or **PATCH** requests in REST, modifying existing data. JPA handles updates by retrieving the entity, modifying it, and saving it back to the database.  
- **Delete** is performed with a **DELETE** request in REST APIs, which removes data from the system. JPA deletes an entity from the database.

Understanding these operations is key to building effective and efficient backend systems.  

> **Documentation:** [CRUD operations](https://albertprofe.dev/springboot/boot-concepts-controller.html#using-annotations) 


---

### Literal Object, Arrow Functions, Spread Operators & Computed Property Names  

As I worked more with JavaScript, I came across some key features that made my code more concise and readable. These features include **Literal Objects**, **Arrow Functions**, **Spread Operators**, and **Computed Property Names**. Here's a quick overview of each:

- **Literal Objects**:  
  A simple and straightforward way to define objects in JavaScript using curly braces. You can define properties directly within the object.  
  ```javascript
  const person = { name: "John", age: 30 };
  ```

- **Arrow Functions**:  
  A shorter syntax for writing functions. They also keep the **`this`** context from the surrounding code, which can help avoid issues with function scoping.  
  ```javascript
  const greet = () => { console.log("Hello!"); };
  ```

- **Spread Operator**:  
  The spread operator allows you to **expand** or **copy** elements from arrays or properties from objects, making code more flexible.  
  ```javascript
  const arr1 = [1, 2, 3];
  const arr2 = [...arr1, 4, 5];  // [1, 2, 3, 4, 5]
  
  const person = { name: "Alice", age: 25 };
  const updatedPerson = { ...person, age: 26 };  // { name: "Alice", age: 26 }
  ```

- **Computed Property Names**:  
  This allows you to define object properties dynamically using expressions. It's useful when the property name needs to be computed at runtime.  
  ```javascript
  const key = "name";
  const person = { [key]: "Bob" };  // { name: "Bob" }
  ```

These features help write cleaner, more efficient JavaScript, especially when working with objects and functions. I found them particularly helpful for simplifying code, making it easier to read and maintain.  

> **Documentation:** [MDN JavaScript Guide](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide)

---

### ENUM

As I started learning about **ENUMs**, I realized they were useful for managing a fixed set of related values. Instead of using regular strings or numbers, which can easily lead to mistakes, ENUMs allow me to define a set of predefined values that make my code more readable and less error-prone.

- An **ENUM** is essentially a way to group together constants with meaningful names.
- In **JavaScript**, we don’t have a built-in `enum` type, but I can use objects to create an enum-like structure.  
- In **TypeScript**, there’s a native `enum` type that is more formal and offers additional features like reverse mappings.

At first, I found it tricky to understand when to use enums over simple constants. But as I worked through examples, I saw how enums help avoid "magic values" in my code, such as random strings or numbers that are hard to understand at a glance.

One of the main benefits I found with enums is that they provide **type safety**. This means I can’t accidentally assign a value that’s not part of the predefined set. This is especially helpful in large codebases where I want to ensure that only valid options are used.

For example, using enums instead of random strings made my code clearer.  
In TypeScript, the syntax for enums was simple, and once I got the hang of it, I could define a set of values with meaningful names, like this:

```typescript
enum Status {
  PENDING = 'Pending',
  APPROVED = 'Approved',
  REJECTED = 'Rejected'
}

let currentStatus: Status = Status.PENDING;
```

This makes my code more understandable and reduces errors that might occur if I used plain strings like `"pending"`, `"approved"`, etc.

ENUMs also help with **maintaining consistency**. If I ever need to change the name or value of a status, I can do it in one place, and it will automatically update everywhere it's used.

I still need more practice with enums, especially as I dive into larger applications. But I can see how they will help in maintaining organized and reliable code as I progress.

> **Documentation:** [MDN Enums (for JavaScript)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const)  | [TypeScript Enums](https://www.typescriptlang.org/docs/handbook/enums.html)

---
### OneToOne, OneToMany, ManyToOne & ManyToMany Annotations

As I was learning JPA (Java Persistence API), I came across some important annotations to define relationships between entities. These relationships help model data in a relational database, and understanding them is key when dealing with database interactions in Java.

- **OneToOne**:  
  This annotation is used when one entity is related to exactly one other entity. For example, a **Person** might have one **Passport**, and a **Passport** belongs to exactly one **Person**.
  
  - **Unidirectional**: Only one entity is aware of the relationship.
  - **Bidirectional**: Both entities are aware of the relationship, using `mappedBy` in the second entity.
  
  ```java
  @OneToOne
  private Passport passport;

- **OneToMany**:
  The OneToMany annotation is used when one entity is related to multiple instances of another entity. For example, a **Customer** may have many **Orders**. This relationship shows that one entity can have many related entities.

  - **Unidirectional**: Only the "one" side knows about the relationship.
  - **Bidirectional**: The "many" side knows about the "one" side using @ManyToOne.

  ```java
  @OneToMany(mappedBy = "customer")
  private List<Order> orders;
  ```

- **ManyToOne**:
  The **ManyToOne** annotation is the inverse of the **OneToMany** relationship. It’s used when many entities can be related to a single instance of another entity. For example, many **Orders** may belong to one **Customer**.

  ```java
  @ManyToOne
  private Customer customer;
  ```

- **ManyToMany**:
The **ManyToMany** annotation is used when two entities can be related to many instances of each other. For example, **Students** may be enrolled in many **Courses**, and each **Course** can have many **Students**.

  ```java
  @ManyToMany
  private List<Course> courses;
  ```

These annotations are essential for defining how entities relate to one another in JPA and mapping these relationships to a relational database.

> **Documentation:** [JPA Anotations](https://github.com/AlbertProfe/cifojava2022-3/wiki/Library3:-API-Rest-Library-Book-@ManyToMany-@OneToOne-CRUD-with-Swagger)